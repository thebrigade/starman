// Generated by IcedCoffeeScript 1.3.3g
(function() {
  var buildOutputTemplateFilePath, cc, ccupOptions, colors, compileLayout, compilePage, compilePages, cs, error, exec, fs, fsextra, handleProcessOutput, iced, makeReleaseDir, path, vm, _, __iced_k, __iced_k_noop,
    __slice = [].slice;

  iced = {
    Deferrals: (function() {

      function _Class(_arg) {
        this.continuation = _arg;
        this.count = 1;
        this.ret = null;
      }

      _Class.prototype._fulfill = function() {
        if (!--this.count) return this.continuation(this.ret);
      };

      _Class.prototype.defer = function(defer_params) {
        var _this = this;
        ++this.count;
        return function() {
          var inner_params, _ref;
          inner_params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (defer_params != null) {
            if ((_ref = defer_params.assign_fn) != null) {
              _ref.apply(null, inner_params);
            }
          }
          return _this._fulfill();
        };
      };

      return _Class;

    })(),
    findDeferral: function() {
      return null;
    },
    trampoline: function(_fn) {
      return _fn();
    }
  };
  __iced_k = __iced_k_noop = function() {};

  fs = require('fs');

  fsextra = require('fs.extra');

  path = require('path');

  vm = require('vm');

  cc = require('coffeecup');

  cs = require('coffee-script');

  colors = require('colors');

  _ = require('underscore');

  exec = require('child_process').exec;

  compilePages = [null][0];

  handleProcessOutput = function(command, err, stdout, stderr) {
    if (stdout != null) console.log(stdout);
    if (stderr != null) console.error(stderr);
    if (err != null) {
      return console.error("the " + command + " command exited with an error, check the output above for more details");
    }
  };

  module.exports = function(callback) {
    var copyErr, csErr, csStderr, csStdout, pagesErr, sassErr, sassStderr, sassStdout, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    (function(__iced_k) {
      try {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/build.iced",
            funcname: "exports"
          });
          exec('rm -rf release/', __iced_deferrals.defer({
            lineno: 20
          }));
          __iced_deferrals._fulfill();
        })(function() {
          fsextra.mkdirRecursiveSync('release');
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/build.iced",
              funcname: "exports"
            });
            fsextra.copyRecursive('./static', './release', __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return copyErr = arguments[0];
                };
              })(),
              lineno: 24
            }));
            exec('sass --scss -t expanded --update -f scss:release/css', __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  sassErr = arguments[0];
                  sassStdout = arguments[1];
                  return sassStderr = arguments[2];
                };
              })(),
              lineno: 24
            }));
            exec('coffee -c -o release/lib/ src/', __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  csErr = arguments[0];
                  csStdout = arguments[1];
                  return csStderr = arguments[2];
                };
              })(),
              lineno: 25
            }));
            compilePages(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return pagesErr = arguments[0];
                };
              })(),
              lineno: 26
            }));
            __iced_deferrals._fulfill();
          })(function() {
            handleProcessOutput('copy', copyErr);
            handleProcessOutput('sass', sassErr, sassStdout, sassStderr);
            handleProcessOutput('coffee', csErr, csStdout, csStderr);
            return handleProcessOutput('compilePages', pagesErr);
          });
        });
      } catch (e) {
        return console.error(e);
      }
    })(function() {
      return typeof callback === "function" ? callback() : void 0;
    });
  };

  makeReleaseDir = _.memoize(function(srcDir) {
    var dirChunks, releaseDir;
    dirChunks = srcDir.split(path.sep);
    dirChunks[0] = 'release';
    releaseDir = dirChunks.join(path.sep);
    fsextra.mkdirRecursiveSync(releaseDir);
    return releaseDir;
  });

  ccupOptions = {
    format: true
  };

  error = function(err) {
    if (err != null) {
      console.log(err);
      return true;
    }
    return false;
  };

  compileLayout = function(callback) {
    var layoutFileContents, layoutTemplate;
    console.log("compiling layout...");
    try {
      layoutFileContents = fs.readFileSync('layout.html.coffee').toString();
      layoutTemplate = cc.compile(layoutFileContents, ccupOptions);
      return typeof callback === "function" ? callback(layoutTemplate) : void 0;
    } catch (e) {
      console.error("failed to compile 'layout.html.coffee':");
      console.error(e);
      return typeof callback === "function" ? callback() : void 0;
    }
  };

  buildOutputTemplateFilePath = function(sourcePath) {
    var dirChunks, fileChunks;
    dirChunks = sourcePath.split(path.sep);
    dirChunks.shift();
    fileChunks = dirChunks.pop().split('.');
    fileChunks.pop();
    return path.join('release', dirChunks.join(path.sep), fileChunks.join('.'));
  };

  compilePage = function(file, layoutTemplate) {
    var compiledContents, context, outputFilePath, pageContents, prop, results, value;
    if (path.extname(file) !== '.coffee') return;
    outputFilePath = buildOutputTemplateFilePath(file);
    console.log("\t" + file + " -> " + outputFilePath);
    try {
      pageContents = fs.readFileSync(file).toString();
      compiledContents = cs.compile(pageContents, {
        bare: true
      });
      context = {};
      vm.runInNewContext(compiledContents, context);
      for (prop in context) {
        value = context[prop];
        if (typeof value !== 'function') continue;
        context[prop] = cc.render(value, context);
      }
      results = layoutTemplate(context);
      return fs.writeFile(outputFilePath, results, 'utf-8');
    } catch (e) {
      return console.error(e);
    }
  };

  compilePages = function(callback) {
    var err, layoutTemplate, options, walker, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    try {
      err = null;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/build.iced",
          funcname: "compilePages"
        });
        compileLayout(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return layoutTemplate = arguments[0];
            };
          })(),
          lineno: 90
        }));
        __iced_deferrals._fulfill();
      })(function() {
        if (!(typeof layoutTemplate !== "undefined" && layoutTemplate !== null)) {
          if (typeof callback === "function") {
            callback("couldn't compile layout.html.coffee");
          }
          return;
        }
        options = {
          followLinks: false
        };
        walker = fsextra.walk('pages', options);
        walker.on('file', function(root, fileStats, next) {
          makeReleaseDir(root);
          compilePage("" + root + "/" + fileStats.name, layoutTemplate);
          return next();
        });
        walker.on("end", function() {});
        if (error(err)) {
          return typeof callback === "function" ? callback(err) : void 0;
        } else {
          return typeof callback === "function" ? callback() : void 0;
        }
      });
    } catch (e) {
      return typeof callback === "function" ? callback(e) : void 0;
    }
  };

}).call(this);
